{"version":3,"sources":["/source/wires-metal.js"],"names":[],"mappings":"qNAiBA,SAAS,GAAM,EAAQ,GACrB,MAAO,YACL,GAAI,GAAY,KAAK,MACrB,MAAK,OAAS,CACd,IAAI,GAAM,EAAO,MAAM,KAAM,UAE7B,OADA,MAAK,OAAS,EACP,GAqBX,QAAS,GAAS,EAAM,GACtB,GAEI,GAAG,EAAM,EAAQ,EAAa,EAF9B,EAAO,EAAE,KAAK,GACd,EAAS,EAAK,MAGlB,KAAK,EAAI,EAAO,EAAJ,EAAY,IACtB,EAAO,EAAK,GACZ,EAAS,EAAO,GAChB,EAAc,EAAK,GAGnB,EAAW,EAAe,KAAK,GAK7B,EAAK,GADH,GAAY,EAAE,WAAW,IAAW,EAAE,WAAW,GACtC,EAAM,EAAQ,GAId,KAhEP,GAAC,EAKT,KA4BE,EAAkB,MAAM,KAAK,GAAI,UAAS,QAAW,aAAe,KAsDtE,EAAQ,EAAM,MAAQ,kBACxB,EAAA,MAAK,WAAU,MAAA,EAAI,WAWrB,GAAM,UAAU,WAAa,EAAE,KAE/B,EAAE,OAAO,GAuBP,OAAM,SAAC,EAAY,GACjB,GACI,GADA,EAAS,IASX,GAHG,GAAe,EAAE,IAAI,EAAY,eAE3B,EAAe,KAAK,EAAW,aAChC,EAAM,EAAW,YAAa,EAAO,UAAU,aAE/C,EAAW,YAJX,WAAa,EAAO,MAAM,KAAM,YAQ1C,EAAE,OAAO,EAAO,GACZ,GACF,EAAS,EAAO,EAKlB,IAAI,GAAY,WAAa,KAAK,YAAc,EAiBhD,OAhBA,GAAU,UAAY,EAAO,UAC7B,EAAM,UAAY,GAAI,GAIlB,GACF,EAAS,EAAM,UAAW,GAI5B,EAAM,WAAa,EAInB,EAAM,UAAY,EAAO,UAElB,GA+BT,MAAK,SAAC,GAGJ,MADA,GAAS,KAAK,UAAW,GAClB,MA0CT,QAAO,SAAC,GAGN,MADA,GAAS,KAAM,GACR,MAqBT,QAAO,SAAC,GACN,QAAS,IACP,YAAiB,IACjB,EAAM,oBAAqB,IAC3B,IAAU,KAahB,IAAI,GAAQ,EAAM,MAAQ,SAAS,GAEjC,EAAE,OAAO,KAAM,GAsBjB,GAAM,QAAU,SAAS,GACvB,QAAS,GAAS,YAAiB,GAOrC,IAAM,IACJ,cAAe,WAAY,aAAc,OAAQ,UAAW,UAiB1D,EAAM,EAAM,MAAQ,EAAM,OAAO,KAAK,OASxC,YAAW,SAAC,MAAS,GAAO,SAAA,UAAA,MAAK,UAAA,EAG3B,GAAE,SAAS,KACb,EAAU,EACV,EAAU,EAAQ,QAIpB,IAAI,GAAQ,MAAM,KAAK,KAAM,EAG7B,GAAE,OAAO,KAAM,EAAE,KAAK,EAAO,GAAc,EAAE,KAAK,EAAS,IAS3D,EAAI,kBAAkB,KAAM,IAU9B,SAAQ,WACN,MAAA,GAAU,KAAK,KAAI,KAAK,KAAK,WAU/B,kBAAiB,SAAC,EAAQ,GACpB,MAAM,mBACR,MAAM,kBAAkB,EAAQ,KAStC,GAAE,OAAO,EAAK,EAYd,IAAI,GAAY,EAAM,UAAY,SAAS,EAAS,GAGrC,SAAT,GAAsB,IAKtB,EAAE,SAAS,KACb,EAAU,EAAU,QAAQ,EAAQ,KAAM,EAAQ,OAIpD,EAAU,GAAW,EAAQ,WAGxB,EAAU,OAAO,KACpB,EAAU,MAAK,wBAAyB,GACxC,EAAU,OAAO,IAAW,IAchC,GAAU,QAAU,SAAS,EAAM,GACjC,MAAA,GAAU,EAAI,qDAAqD,EAAI,aAYzE,EAAU,MAA2B,mBAAZ,WAA4B,QAAQ,MAAQ,QAAQ,MAAQ,EAAE,KAUvF,EAAU,oBAEK","file":"wires-metal.min.js","sourcesContent":["import * as _ from 'lodash';\n\n/**\n * @module Metal\n */\nvar Metal = {};\n\n/**\n * Wraps the passed method so that `this._super` will point to the superMethod\n * when the method is invoked.\n *\n * @private\n * @method wrap\n * @param {Function} method - The method to call.\n * @param {Function} superMeqthod - The super method.\n * @return {Function} - wrapped function.\n */\nfunction _wrap(method, superMethod) {\n  return function() {\n    var prevSuper = this._super;\n    this._super = superMethod;\n    var ret = method.apply(this, arguments);\n    this._super = prevSuper;\n    return ret;\n  };\n}\n\n/**\n * A reference to safe regex for checking if a function calls `_super`.\n *\n * @private\n * @const {RegExp}\n */\nconst CONTAINS_SUPER = (/xyz/.test(new Function('xyz'))) ? /\\b_super\\b/ : /.*/;\n\n/**\n * Assigns properties of source object to destination object, wrapping methods\n * that call their super method.\n *\n * @private\n * @method wrapAll\n * @param {Object} dest - The destination object.\n * @param {Object} source - The source object.\n */\nfunction _wrapAll(dest, source) {\n  var keys = _.keys(source),\n      length = keys.length,\n      i, name, method, superMethod, hasSuper;\n\n  for (i = 0; i < length; i++) {\n    name = keys[i];\n    method = source[name];\n    superMethod = dest[name];\n\n    // Test if new method calls `_super`\n    hasSuper = CONTAINS_SUPER.test(method);\n\n    // Only wrap the new method if the original method was a function and the\n    // new method calls `_super`.\n    if (hasSuper && _.isFunction(method) && _.isFunction(superMethod)) {\n      dest[name] = _wrap(method, superMethod);\n\n    // Otherwise just add the new method or property to the object.\n    } else {\n      dest[name] = method;\n    }\n  }\n}\n\n/**\n * Creates a new Class.\n *\n * ```js\n * var MyClass = Class.extend({\n *   initialize() {\n *     console.log('Created!');\n *   }\n * });\n *\n * new MyClass();\n * // >> Created!\n * ```\n *\n * @public\n * @class Class\n * @memberOf Metal\n */\nvar Class = Metal.Class = function() {\n  this.initialize(...arguments);\n};\n\n/**\n * An overridable method called when objects are instantiated. Does not do\n * anything by default.\n *\n * @public\n * @abstract\n * @method initialize\n */\nClass.prototype.initialize = _.noop;\n\n_.assign(Class, {\n\n  /**\n   * Creates a new subclass.\n   *\n   * ```js\n   * var MyClass = Class.extend({\n   *   // ...\n   * });\n   *\n   * var myClass = new MyClass();\n   * myClass instanceof MyClass\n   * // true\n   * myClass instanceof Class\n   * // true\n   * ```\n   *\n   * @public\n   * @static\n   * @method extend\n   * @param {Object} [protoProps] - The properties to be added to the prototype.\n   * @param {Object} [staticProps] - The properties to be added to the constructor.\n   */\n  extend(protoProps, staticProps) {\n    var Parent = this;\n    var Child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (!protoProps || !_.has(protoProps, 'constructor')) {\n      Child = function() { Parent.apply(this, arguments); };\n    } else if (CONTAINS_SUPER.test(protoProps.constructor)) {\n      Child = _wrap(protoProps.constructor, Parent.prototype.constructor);\n    } else {\n      Child = protoProps.constructor;\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.assign(Child, Parent);\n    if (staticProps) {\n      _wrapAll(Child, staticProps);\n    }\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function() { this.constructor = Child; };\n    Surrogate.prototype = Parent.prototype;\n    Child.prototype = new Surrogate();\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) {\n      _wrapAll(Child.prototype, protoProps);\n    }\n\n    // Set a convenience property in case the parent class is needed later.\n    Child.superclass = Parent;\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    Child.__super__ = Parent.prototype;\n\n    return Child;\n  },\n\n  /**\n   * Mixes properties onto the class's prototype.\n   *\n   * ```js\n   * var MyMixin = new Mixin({\n   *   alert() {\n   *     console.log('Alert!');\n   *   }\n   * });\n   *\n   * var MyClass = Class.extend({\n   *   initialize() {\n   *     this.alert();\n   *   }\n   * });\n   *\n   * MyClass.mixin(MyMixin);\n   *\n   * new MyClass();\n   * // >> Alert!\n   * ```\n   *\n   * @public\n   * @static\n   * @method mixin\n   * @param {Object} protoProps - The properties to be added to the prototype.\n   * @return {Class} - The class.\n   */\n  mixin(protoProps) {\n    // Add prototype properties (instance properties) to the class, if supplied.\n    _wrapAll(this.prototype, protoProps);\n    return this;\n  },\n\n  /**\n   * Mixes properties onto the class's constructor.\n   *\n   * ```js\n   * var MyMixin = new Mixin({\n   *   alert() {\n   *     console.log('Alert!');\n   *   }\n   * });\n   *\n   * var MyClass = Class.extend(...);\n   *\n   * MyClass.include(MyMixin);\n   *\n   * MyClass.alert();\n   * // >> Alert!\n   * ```\n   *\n   * You can also simply pass a plain javascript object.\n   *\n   * ```js\n   * var MyClass = Class.extend(...);\n   *\n   * MyClass.include({\n   *   alert() {\n   *     console.log('Alert!');\n   *   }\n   * });\n   *\n   * MyClass.alert();\n   * // >> Alert!\n   * ```\n   *\n   * @public\n   * @static\n   * @method mixin\n   * @param {Object} staticProps - The properties to be added to the constructor.\n   * @return {Class} - The class.\n   */\n  include(staticProps) {\n    // Add static properties to the constructor function, if supplied.\n    _wrapAll(this, staticProps);\n    return this;\n  },\n\n  /**\n   * Checks if `value` is a Metal Class.\n   *\n   * ```js\n   * _.isClass(Class.extend(...));\n   * // >> true\n   * _.isClass(new Class());\n   * // >> true\n   * _.isClass(function() {...});\n   * // >> false\n   * _.isClass({...});\n   * // >> false\n   * ```\n   * @public\n   * @method isClass\n   * @memberOf _\n   * @param {*} value - The value to check.\n   */\n  isClass(value) {\n    return !!value && (\n      value instanceof Class ||\n      value.prototype instanceof Class ||\n      value === Class\n    );\n  }\n});\n\n/**\n * Allows you to create mixins, whose properties can be added to other classes.\n *\n * @public\n * @class Mixin\n * @memberOf Metal\n * @param {Object} protoProps - The properties to be added to the prototype.\n */\nvar Mixin = Metal.Mixin = function(protoProps) {\n  // Add prototype properties (instance properties) to the class, if supplied.\n  _.assign(this, protoProps);\n};\n\n/**\n * Checks if `value` is a Metal Mixin.\n *\n * ```js\n * _.isMixin(new Mixin());\n * // >> true\n * _.isMixin({});\n * // >> false\n * _.isMixin(function() {...});\n * // >> false\n * _.isMixin(new Class());\n * // >> false\n * ```\n *\n * @public\n * @method isMixin\n * @memberOf _\n * @param {*} value - The value to check.\n */\nMixin.isMixin = function(value) {\n  return !!value && value instanceof Mixin;\n};\n\n/**\n * @private\n * @const {String[]}\n */\nconst ERROR_PROPS = [\n  'description', 'fileName', 'lineNumber', 'name', 'message', 'number'\n];\n\n/**\n * A subclass of the JavaScript Error.\n *\n * ```js\n * throw new Metal.Error('Oh you\\'ve really done it now...');\n * // Uncaught Metal.Error: Oh you've really done it now...\n * //   [stack trace]\n * ```\n *\n * @class Error\n * @memberOf Metal\n * @extends Error\n * @uses Metal.Class\n */\nvar Err = Metal.Error = Class.extend.call(Error, {\n\n  /**\n   * @public\n   * @constructs Error\n   * @param {String} [message] - A description of the error.\n   * @param {Object} [options] - Settings for the error.\n   * @param {String} [options.message] - A description of the error.\n   */\n  constructor(message, options = {}) {\n    // If options are provided in place of a message, assume message exists on\n    // options.\n    if (_.isObject(message)) {\n      options = message;\n      message = options.message;\n    }\n\n    // Create a fake error with message in order to capture a stack trace.\n    var error = Error.call(this, message);\n\n    // Copy over all the error-related properties.\n    _.assign(this, _.pick(error, ERROR_PROPS), _.pick(options, ERROR_PROPS));\n\n    // Adds a `stack` property to the given error object that will yield the\n    // stack trace at the time captureStackTrace was called.\n    // When collecting the stack trace all frames above the topmost call\n    // to this function, including that call, will be left out of the\n    // stack trace.\n    // This is useful because we can hide Metal implementation details\n    // that are not very helpful for the user.\n    Err.captureStackTrace(this, Err);\n  },\n\n  /**\n   * Formats the error message to display in the console.\n   *\n   * @public\n   * @method toString\n   * @returns {String} - Formatted error message.\n   */\n  toString() {\n    return `${this.name}: ${this.message}`;\n  }\n}, {\n\n  /**\n   * A safe reference to V8's `Error.captureStackTrace`.\n   *\n   * @public\n   * @method captureStackTrace\n   */\n  captureStackTrace(target, method) {\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(target, method);\n    }\n  }\n});\n\n/**\n * @class Error\n * @mixes Class\n */\n_.assign(Err, Class);\n\n/**\n * Display a deprecation warning with the provided message.\n *\n * @public\n * @method deprecate\n * @param {String|Object} message - A description of the deprecation.\n * @param {String} message.prev - The deprecated item.\n * @param {String} message.next - The replacement for the deprecated item.\n * @param {Boolean} [test] - An optional boolean. If falsy, the deprecation will be displayed.\n */\nvar deprecate = Metal.deprecate = function(message, test) {\n\n  // Returns if test is provided and is falsy.\n  if (test !== undefined && test) {\n    return;\n  }\n\n  // If message is provided as an object, format the object into a string.\n  if (_.isObject(message)) {\n    message = deprecate._format(message.prev, message.next);\n  }\n\n  // Ensure that message is a string\n  message = message && message.toString();\n\n  // If deprecation message has not already been warned, send the warning.\n  if (!deprecate._cache[message]) {\n    deprecate._warn(`Deprecation warning: ${message}`);\n    deprecate._cache[message] = true;\n  }\n};\n\n/**\n * Format a message for deprecate.\n *\n * @private\n * @method _format\n * @memberOf deprecate\n * @param {String} prev - The deprecated item.\n * @param {String} next - The replacement for the deprecated item.\n * @return {String} - The formatted message.\n */\ndeprecate._format = function(prev, next) {\n  return `${prev} is going to be removed in the future. Please use ${next} instead.`;\n};\n\n/**\n * A safe reference to `console.warn` that will fallback to `console.log` or\n * `_noop` if the `console` object does not exist.\n *\n * @private\n * @method _warn\n * @memberOf deprecate\n * @param {*...} - The values to warn in the console.\n */\ndeprecate._warn = typeof console !== 'undefined' && (console.warn || console.log) || _.noop;\n\n/**\n * An internal cache to avoid sending the same deprecation warning multiple\n * times.\n *\n * @private\n * @property _cache\n * @memberOf deprecate\n */\ndeprecate._cache = {};\n\nexport default Metal;\n"],"sourceRoot":"/source/"}